// Code Generation, Macros
var x = { Ringz(Dust(0.1), Rand(1200, 2400), Rand(1, 3)) * Rand(0, 0.05) };
{ SinOsc(Rand(110, 220), 0) * Rand(0, 0.05) }.dup(16).splay + x.dup(16).splay

//---- notes.md
There is a sense in which this simple program could be made simpler still.

The 𝑓 (_proc_) input to the ! (_ArrayFill_) block is a no argument λ (_Proc_)
that is evaluated # (_count_) times to generate an ⟦⟧ (_Array_) of # places.

! prints itself as:

> _proc.dup(count)_

! requires that the 𝑓 input be a λ,
however it could equally allow the λ to be elided,
and print itself as:

> _{ proc }.dup(count)_

This imaginary form of ! would be what is sometimes called a _macro_.
In an imaginary program using this ! the λ blocks would not be required.
The first ! block (containing ∿) would print exactly as it currently does, i.e.:

> _{ SinOsc... }.dup(16)_

There is a subtle difficulty with macros however, which is illustrated by the second ! block.

In this instance we have given a name (_x_) to the λ block (containing ⋏ₜ),
and the 𝑓 input to ! is now a reference to this variable.
The macro form of ! would print this as:

> _{ x }.dup(16)_

which would make an array containing the same value (_x_) at each place.

_blksc3_ does not implement any _macro_ like blocks,
instead requiring that λ blocks be provided in programs as required.

